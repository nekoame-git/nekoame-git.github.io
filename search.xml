<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bootstrap学习笔记</title>
    <url>/2021/11/28/Bootstrap%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Bootstrap学习笔记"><a href="#Bootstrap学习笔记" class="headerlink" title="Bootstrap学习笔记"></a>Bootstrap学习笔记</h1><h2 id="一、栅格系统"><a href="#一、栅格系统" class="headerlink" title="一、栅格系统"></a>一、栅格系统</h2><p>通过一系列的行(row)与列(column)的组合来创建页面布局，按照不同尺寸屏幕分为1~12份</p>
<table>
<thead>
<tr>
<th></th>
<th>超小屏幕手机 (&lt;768px)</th>
<th>小屏幕平板 (≥768px)</th>
<th>中等屏幕桌面 (≥992px)</th>
<th>大屏幕桌面 (≥1200px)</th>
</tr>
</thead>
<tbody><tr>
<td>.container最大宽度</td>
<td>自动(100%)</td>
<td>750px</td>
<td>970px</td>
<td>1170px</td>
</tr>
<tr>
<td>类前缀</td>
<td>.col-xs-</td>
<td>.col-sm-</td>
<td>.col-md-</td>
<td>.col-lg-</td>
</tr>
<tr>
<td>列数(column)</td>
<td></td>
<td></td>
<td>12</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>按照不同屏幕划分为1~12等份</li>
<li>行(row)可以去除父容器作用12px的边距</li>
<li>xs：extra small</li>
<li>列大于12，多余的列所在的元素将被作为一个整体另起一行</li>
<li>每一列默认有左右15px的padding，因此内容互相间隔30px左右</li>
<li>不能再加margin值，否则会挤掉盒子</li>
<li>可以同时为一列指定多个设备的类名，一遍划分不同份数，例如<div class="col-lg-6 col-md-4"></div></li>
</ul>
<h2 id="二、列嵌套"><a href="#二、列嵌套" class="headerlink" title="二、列嵌套"></a>二、列嵌套</h2><p>一个列(row)内再分为12等份。可以通过添加一个新的.row元素和一系列.col-sm-元素到已经存在的.col-sm-元素内。</p>
<p>​    嵌套可以像下面多加一个row，消除父盒子row的padding值，而且高度自动和父级一样高</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> &lt;<span class="selector-tag">div</span> class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;row&quot;&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class=&quot;col-lg-<span class="number">6</span> col-md-<span class="number">3</span>&quot;&gt;</span><br><span class="line"><span class="comment">/*嵌套可以像下面多加一个row，消除父盒子row的padding值，而且高度自动和父级一样高*/</span></span><br><span class="line">                &lt;<span class="selector-tag">div</span> class=&quot;row&quot;&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">div</span> class=&quot;col-md-<span class="number">3</span>&quot;&gt;<span class="number">5</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">div</span> class=&quot;col-md-<span class="number">3</span>&quot;&gt;<span class="number">6</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">div</span> class=&quot;col-md-<span class="number">3</span>&quot;&gt;<span class="number">7</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">                    &lt;<span class="selector-tag">div</span> class=&quot;col-md-<span class="number">3</span>&quot;&gt;<span class="number">8</span>&lt;/<span class="selector-tag">div</span>&gt;<span class="number">1</span></span><br><span class="line">                &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class=&quot;col-lg-<span class="number">1</span> col-md-<span class="number">3</span>&quot;&gt;<span class="number">2</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class=&quot;col-lg-<span class="number">3</span> col-md-<span class="number">3</span>&quot;&gt;<span class="number">3</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">            &lt;<span class="selector-tag">div</span> class=&quot;col-lg-<span class="number">2</span> col-md-<span class="number">3</span>&quot;&gt;<span class="number">4</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、列偏移"><a href="#三、列偏移" class="headerlink" title="三、列偏移"></a>三、列偏移</h2><p>使用.col-md-offset-类将列右偏移，实际上是通过使用选择器为当前元素增加了左侧的边距(margin)。</p>
<p>通过控制自身列宽数和偏移的列宽数，同理也可以实现居中，右对齐</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;row&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;col-md-<span class="number">3</span>&quot;&gt;左侧&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">		将列从原来位置右偏移<span class="number">6</span>列，效果是将右侧贴着右边</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;col-md-<span class="number">3</span> col-md-offset-<span class="number">6</span>&quot;&gt;右侧&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="四、列排序"><a href="#四、列排序" class="headerlink" title="四、列排序"></a>四、列排序</h2><p>使用.col-md-push-和.col-md-pull-类就可以很容易地改变列(column)的顺序</p>
<ul>
<li>.col-md-pull-         往左拉x个格子</li>
<li>.col-md-push-        往右推x个格子</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;row&quot;&gt;</span><br><span class="line">	<span class="comment">/*实现了左右侧格子的调换*/</span></span><br><span class="line">  			&lt;<span class="selector-tag">div</span> class=&quot;col-lg-<span class="number">3</span> col-md-<span class="number">3</span> col-md-push-<span class="number">9</span>&quot;&gt;左侧的<span class="number">3</span>格，右移<span class="number">9</span>格&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">   			&lt;<span class="selector-tag">div</span> class=&quot;col-lg-<span class="number">9</span> col-md-<span class="number">9</span> col-md-pull-<span class="number">3</span>&quot;&gt;右侧的<span class="number">9</span>格，左移<span class="number">3</span>格&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="五、响应式工具"><a href="#五、响应式工具" class="headerlink" title="五、响应式工具"></a>五、响应式工具</h2><p>通过单独或联合使用以下列出的类，可以针对不同屏幕尺寸隐藏或显示页面内容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">超小屏幕手机 (&lt;768px)</th>
<th align="left">小屏幕平板 (≥768px)</th>
<th align="left">中等屏幕桌面 (≥992px)</th>
<th>大屏幕桌面 (≥1200px)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.visible-xs-*</code></td>
<td align="left"><strong>可见</strong></td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td>隐藏</td>
</tr>
<tr>
<td align="left"><code>.visible-sm-*</code></td>
<td align="left">隐藏</td>
<td align="left"><strong>可见</strong></td>
<td align="left">隐藏</td>
<td>隐藏</td>
</tr>
<tr>
<td align="left"><code>.visible-md-*</code></td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td align="left"><strong>可见</strong></td>
<td>隐藏</td>
</tr>
<tr>
<td align="left"><code>.visible-lg-*</code></td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td align="left">隐藏</td>
<td><strong>可见</strong></td>
</tr>
<tr>
<td align="left"><code>.hidden-xs</code></td>
<td align="left">隐藏</td>
<td align="left"><strong>可见</strong></td>
<td align="left"><strong>可见</strong></td>
<td><strong>可见</strong></td>
</tr>
<tr>
<td align="left"><code>.hidden-sm</code></td>
<td align="left"><strong>可见</strong></td>
<td align="left">隐藏</td>
<td align="left"><strong>可见</strong></td>
<td><strong>可见</strong></td>
</tr>
<tr>
<td align="left"><code>.hidden-md</code></td>
<td align="left"><strong>可见</strong></td>
<td align="left"><strong>可见</strong></td>
<td align="left">隐藏</td>
<td><strong>可见</strong></td>
</tr>
<tr>
<td align="left"><code>.hidden-lg</code></td>
<td align="left"><strong>可见</strong></td>
<td align="left"><strong>可见</strong></td>
<td align="left"><strong>可见</strong></td>
<td>隐藏</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Bootstrap</tag>
        <tag>响应式布局</tag>
        <tag>前端</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/28/CSS%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h1><h2 id="一、层叠性"><a href="#一、层叠性" class="headerlink" title="一、层叠性"></a>一、层叠性</h2><p>​    样式冲突，遵循就近原则，执行样式离结构近的</p>
<p>​    样式不冲突则不层叠</p>
<h2 id="二、继承性"><a href="#二、继承性" class="headerlink" title="二、继承性"></a>二、继承性</h2><p>子标签会继承父标签的某些样式，如文本颜色和字号</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>	&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">     &lt;<span class="selector-tag">p</span>&gt;继承<span class="selector-tag">div</span>的样式，变为红色&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>恰当使用继承可以简化代码，降低CSS的复杂性</p>
<p>子元素可以继承父元素的样式 （<strong>text-，font-，line-等开头的元素可以继承，以及color属性</strong>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">12px</span>/<span class="number">24px</span>;	<span class="number">12</span>为字号，<span class="number">24</span>为行高</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">12px</span>/<span class="number">1.5</span>;		</span><br><span class="line">    <span class="comment">/*不跟单位时候，1.5则表示子元素div的行高*1.5倍，即10*1.5px=15px*/</span></span><br><span class="line">    行高使用倍数方便子元素根据字体大小自动调整行高</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;继承<span class="selector-tag">body</span>行高，<span class="number">1.5</span>*<span class="number">10</span>=<span class="number">15px</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">	&lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">		&lt;/<span class="selector-tag">li</span>&gt;<span class="selector-tag">li</span>继承父类的大小行高，父类<span class="selector-tag">ul</span>未指定则再上一层<span class="selector-tag">body</span>，而<span class="selector-tag">body</span>的字体大小为<span class="number">12</span>，行高<span class="number">1.5</span>，则行高最后为当前文字大小的<span class="number">1.5</span>倍，则为<span class="number">12px</span>*<span class="number">1.5</span>=<span class="number">18px</span>&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">	&lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="三、优先级"><a href="#三、优先级" class="headerlink" title="三、优先级"></a>三、优先级</h2><p>选择器权重</p>
<table>
<thead>
<tr>
<th align="left">标签选择器</th>
<th align="left">计算权重公式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承或者 *</td>
<td align="left">0,0,0,0</td>
</tr>
<tr>
<td align="left">每个元素（标签选择器）</td>
<td align="left">0,0,0,1</td>
</tr>
<tr>
<td align="left">每个类，伪类</td>
<td align="left">0,0,1,0</td>
</tr>
<tr>
<td align="left">每个ID</td>
<td align="left">0,1,0,0</td>
</tr>
<tr>
<td align="left">每个行内样式 style=””</td>
<td align="left">1,0,0,0</td>
</tr>
<tr>
<td align="left">每个!important  最重要的</td>
<td align="left">∞ 无穷大</td>
</tr>
</tbody></table>
<p>值从左到右，左面的最大，一级大于一级，数位之间没有进制（会加到0,0,0,7也不会有进位），级别之间不可超越。</p>
<p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p>
<p>div { color: pink !important; }</p>
<p>注意权重对应的<strong>对象</strong>是谁，有可能对于这个标签来说其实是继承。</p>
<p>不管父元素的权重多高，子元素得到的权重都只是继承而已。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        <span class="selector-class">.test</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: red;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">div</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: pink<span class="meta">!important</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-id">#demo</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: green;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;test&quot; id=&quot;demo&quot; style=&quot;<span class="attribute">color</span>: purple<span class="string">&quot;&gt;你笑起来真好看&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>权重叠加：</strong>（如果是复合选择器，则会有权重叠加）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">ul</span>  <span class="selector-tag">li</span>   ------&gt;      <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>	三个标签选择器权重相加</span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>   ------&gt;      <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>	</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>      -----—&gt;      <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>	伪类 加 标签</span><br><span class="line"><span class="selector-class">.nav</span> <span class="selector-tag">a</span>       ------&gt;      <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>	</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">    &lt;style&gt;</span><br><span class="line">        <span class="comment">/* .nav li  权重是 11 */</span></span><br><span class="line">        <span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: red;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 需求把第一个小li 颜色改为 粉色加粗 ? */</span></span><br><span class="line">        <span class="comment">/* .pink  权重是 10  */</span></span><br><span class="line">       <span class="selector-class">.nav</span> &#123;</span><br><span class="line">            <span class="attribute">color</span>: pink;</span><br><span class="line">            <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;  </span><br><span class="line">    &lt;<span class="selector-tag">ul</span> class=&quot;<span class="selector-tag">nav</span>&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span> class=&quot;pink&quot;&gt;人生四大悲&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;家里没宽带&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;网速不够快&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;手机没流量&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">li</span>&gt;学校没wifi&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">    &lt;/<span class="selector-tag">ul</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>这里.nav未产生继承，因为.nav后面加了li，所以直接选择了li元素，所以.nav算为类的权重</strong></p>
]]></content>
  </entry>
  <entry>
    <title>css背景设置</title>
    <url>/2021/09/23/CSS%E8%83%8C%E6%99%AF%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="CSS背景选择"><a href="#CSS背景选择" class="headerlink" title="CSS背景选择"></a><strong>CSS背景选择</strong></h2><h5 id="一、background-color-颜色值-设置背景颜色，默认transparent-透明色"><a href="#一、background-color-颜色值-设置背景颜色，默认transparent-透明色" class="headerlink" title="一、background-color: 颜色值       设置背景颜色，默认transparent(透明色)"></a>一、<strong>background-color:</strong> 颜色值       设置背景颜色，默认transparent(透明色)</h5><h5 id="二、background-image：none-url-用于添加背景图片（例如超大的背景界面），比直接插入图片更加容易控制位置。"><a href="#二、background-image：none-url-用于添加背景图片（例如超大的背景界面），比直接插入图片更加容易控制位置。" class="headerlink" title="二、background-image：none/url()   用于添加背景图片（例如超大的背景界面），比直接插入图片更加容易控制位置。"></a>二、<strong>background-image：none/url()</strong>   用于添加背景图片（例如超大的背景界面），比直接插入图片更加容易控制位置。</h5><h5 id="三、background-repeat：图片平铺（默认平铺）"><a href="#三、background-repeat：图片平铺（默认平铺）" class="headerlink" title="三、background-repeat：图片平铺（默认平铺）"></a>三、<strong>background-repeat：</strong>图片平铺（默认平铺）</h5><p>​    = repeat-x | repeat-y |  [repeat | no-repeat | space | round]{1,2}</p>
<p>​    repeat-x： 背景图像在横向上平铺 </p>
<p>​    repeat-y： 背景图像在纵向上平铺 </p>
<p>​    repeat： 背景图像在横向和纵向平铺 </p>
<p>​    no-repeat： 背景图像不平铺 </p>
<p>​    round： 背景图像自动缩放直到适应且填充满整个容器。（CSS3） </p>
<p>​    space： 背景图像以相同的间距平铺且填充满整个容器或某个方向。（CSS3）</p>
<h5 id="四、background-position：x-y-设置图片在背景中的位置，方位名词可以使用两个值-不分顺序-，例如center-top（尽量）-若第二个省略，则默认为居中。"><a href="#四、background-position：x-y-设置图片在背景中的位置，方位名词可以使用两个值-不分顺序-，例如center-top（尽量）-若第二个省略，则默认为居中。" class="headerlink" title="四、background-position：x  y;**    设置图片在背景中的位置，方位名词可以使用两个值(不分顺序)，例如center top（尽量）;若第二个省略，则默认为居中。"></a><strong>四、background-position：x  y</strong>;**    设置图片在背景中的位置，方位名词可以使用两个值(不分顺序)，例如center top（尽量）;若第二个省略，则默认为居中。</h5><h6 id="1、方位名词："><a href="#1、方位名词：" class="headerlink" title="1、方位名词："></a>1、方位名词：</h6><p>​        percentage： 用百分比指定背景图像填充的位置。可以为负值。其参考的尺寸        为容器大小减去背景图片大小 </p>
<p>​        length： 用长度值指定背景图像填充的位置。可以为负值。 </p>
<p>​        center： 背景图像横向和纵向居中。 </p>
<p>​        left： 背景图像在横向上填充从左边开始。 </p>
<p>​        right： 背景图像在横向上填充从右边开始。 </p>
<p>​        top： 背景图像在纵向上填充从顶部开始。 </p>
<p>​        bottom： 背景图像在纵向上填充从底部开始。 </p>
<h6 id="2、精确单位"><a href="#2、精确单位" class="headerlink" title="2、精确单位"></a>2、精确单位</h6><p>​        x和y均为相对左上角的坐标。第一个数值一定为x坐标，第二个不填则默认垂        直居中</p>
<h6 id="3、混合坐标，第一个也一定为x坐标方向的位置"><a href="#3、混合坐标，第一个也一定为x坐标方向的位置" class="headerlink" title="3、混合坐标，第一个也一定为x坐标方向的位置"></a>3、混合坐标，第一个也一定为x坐标方向的位置</h6><h5 id="五、background-attachment：；背景图像固定（背景附着，不随滚动）"><a href="#五、background-attachment：；背景图像固定（背景附着，不随滚动）" class="headerlink" title="五、background-attachment：；背景图像固定（背景附着，不随滚动）"></a><strong>五、background-attachment</strong>：；背景图像固定（背景附着，不随滚动）</h5><p>​    fixed： 背景图像相对于窗体固定，不随着滚动。 </p>
<p>​    scroll： 背景图像相对于元素固定，也就是说当元素内容滚动时背景图像不会跟    着滚动，因为背景图像总是要跟着元素本身。但会随元素的祖先元素或窗体一起    滚动。 </p>
<p>​    local： 背景图像相对于元素内容固定，也就是说当元素随元素滚动时背景图像    也会跟着滚动，因为背景图像总是要跟着内容。（CSS3） </p>
<h5 id="六、背景属性复合写法（之间用空格分开）"><a href="#六、背景属性复合写法（之间用空格分开）" class="headerlink" title="六、背景属性复合写法（之间用空格分开）"></a>六、背景属性复合写法（之间用空格分开）</h5><p>规范写法：</p>
<p>​    background: 背景颜色  背景图片地址  背景平铺   背景图像滚动   背景图片位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: transparent <span class="built_in">url</span>() no-repeat fixed center top</span><br><span class="line">background:black <span class="built_in">url</span>(<span class="string">test1.jpg</span>) no-repeat scroll <span class="number">10px</span> <span class="number">20px</span> </span><br></pre></td></tr></table></figure>



<h5 id="七、背景色半透明（盒子里的内容不受影响）"><a href="#七、背景色半透明（盒子里的内容不受影响）" class="headerlink" title="七、背景色半透明（盒子里的内容不受影响）"></a><strong>七、背景色半透明（盒子里的内容不受影响）</strong></h5><p>最后一个参数为alpha透明度，取值范围0~1之间</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(red, green, blue, alpha);</span><br></pre></td></tr></table></figure>

<h3 id="CSS背景总结"><a href="#CSS背景总结" class="headerlink" title="CSS背景总结"></a><strong>CSS背景总结</strong></h3><p><img src="http://blog.nekoame.club/usr/uploads/2021/09/3992008468.png"></p>
]]></content>
  </entry>
  <entry>
    <title>css背景设置</title>
    <url>/2021/09/23/CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="CSS-三角形"><a href="#CSS-三角形" class="headerlink" title="CSS 三角形"></a><strong>CSS 三角形</strong></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">0</span>; </span><br><span class="line">   <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">line-height</span>:<span class="number">0</span>；</span><br><span class="line">   font-size: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">border-top</span>: <span class="number">10px</span> solid red;</span><br><span class="line">   <span class="attribute">border-right</span>: <span class="number">10px</span> solid green;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid blue;</span><br><span class="line">   <span class="attribute">border-left</span>: <span class="number">10px</span> solid <span class="number">#000</span>; </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们用css <strong>边框</strong>border可以模拟三角效果</li>
<li>内容宽度高度为0</li>
<li>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了</li>
<li>为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</li>
</ol>
<h3 id="CSS用户界面样式"><a href="#CSS用户界面样式" class="headerlink" title="CSS用户界面样式"></a><strong>CSS用户界面样式</strong></h3><p>所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。</p>
<ul>
<li>更改用户的鼠标样式</li>
<li>表单轮廓等。</li>
<li>防止表单域拖拽</li>
</ul>
<h4 id="2-1-鼠标样式"><a href="#2-1-鼠标样式" class="headerlink" title="2.1 鼠标样式"></a>2.1 鼠标样式</h4><p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">default</td>
<td align="left">小白  默认</td>
</tr>
<tr>
<td align="left">pointer</td>
<td align="left">小手</td>
</tr>
<tr>
<td align="left">move</td>
<td align="left">移动</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">文本</td>
</tr>
<tr>
<td align="left">not-allowed</td>
<td align="left">禁止</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span> style=&quot;<span class="attribute">cursor</span><span class="selector-pseudo">:default</span>&quot;&gt;我是小白&lt;/<span class="selector-tag">li</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span> style=&quot;<span class="attribute">cursor</span>:pointer<span class="string">&quot;&gt;我是小手&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li style=&quot;</span>cursor:move<span class="string">&quot;&gt;我是移动&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li style=&quot;</span>cursor:text<span class="string">&quot;&gt;我是文本&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li style=&quot;</span>cursor:not-allowed<span class="string">&quot;&gt;我是文本&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-轮廓线-outline"><a href="#2-2-轮廓线-outline" class="headerlink" title="2.2 轮廓线 outline"></a>2.2 轮廓线 outline</h4><p>是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">outline</span> : outline-color ||outline-style || outline-width </span><br></pre></td></tr></table></figure>

<p><strong>一般为消除表单的轮廓线</strong><br>最直接的写法是 ： outline: 0;  或者  outline: none;</p>
<h4 id="2-3-防止拖拽文本域resize"><a href="#2-3-防止拖拽文本域resize" class="headerlink" title="2.3 防止拖拽文本域resize"></a>2.3 防止拖拽文本域resize</h4><p>![图片](../images/CSS 三角形/640.webp)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">textarea</span>  style=&quot;<span class="attribute">resize</span>: none;&quot;&gt;&lt;/<span class="selector-tag">textarea</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-用户界面样式总结"><a href="#2-4-用户界面样式总结" class="headerlink" title="2.4 用户界面样式总结"></a>2.4 用户界面样式总结</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">用途</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">鼠标样式</td>
<td align="left">更改鼠标样式cursor</td>
<td align="left">样式很多，重点记住 pointer</td>
</tr>
<tr>
<td align="left">轮廓线</td>
<td align="left">表单默认outline</td>
<td align="left">outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用</td>
</tr>
<tr>
<td align="left">防止拖拽</td>
<td align="left">主要针对文本域resize</td>
<td align="left">防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none</td>
</tr>
</tbody></table>
<h2 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align 垂直对齐"></a>vertical-align 垂直对齐</h2><ul>
<li>有宽度的块级元素居中对齐，是margin: 0 auto;</li>
<li>让文字居中对齐，是 text-align: center;</li>
</ul>
<p>vertical-align 垂直对齐，它只针对于<strong>「行内元素」</strong>或者<strong>「行内块元素」</strong></p>
<p><img src="../images/CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/%E5%AD%97%E4%BD%93%E7%BA%BF.jpg"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">设置或检索对象内容的垂直对其方式。</span><br><span class="line"><span class="attribute">vertical-align</span> : baseline 基线|top 顶线 |middle中线 |bottom 底线</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于整体<strong>「行内元素」</strong>或者<strong>「行内块元素」</strong>，</p>
<p>特别是行内块元素， 通常用来控制图片/表单与文字的对齐。</p>
<h4 id="3-1-图片、表单和文字对齐"><a href="#3-1-图片、表单和文字对齐" class="headerlink" title="3.1 图片、表单和文字对齐"></a>3.1 图片、表单和文字对齐</h4><p>我们可以通过<code>vertical-align</code> 控制图片和文字的垂直关系了。默认的图片会和文字基线对齐。</p>
<p><img src="../images/CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/vertical-align.jpg" alt="图片"></p>
<h4 id="3-2-去图片底侧空白缝隙"><a href="#3-2-去图片底侧空白缝隙" class="headerlink" title="3.2 去图片底侧空白缝隙"></a>3.2 去图片底侧空白缝隙</h4><p><strong>原因：</strong>图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。</p>
<p>就是图片底侧会有一个空白缝隙。</p>
<p><strong>解决方法：</strong></p>
<ul>
<li><p>给img  vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。</p>
</li>
<li><p>给img 添加 display：block; 转换为块级元素就不会存在问题了。</p>
</li>
</ul>
<h3 id="溢出的文字省略号显示"><a href="#溢出的文字省略号显示" class="headerlink" title="溢出的文字省略号显示"></a>溢出的文字省略号显示</h3><h4 id="4-1-white-space"><a href="#4-1-white-space" class="headerlink" title="4.1 white-space"></a>4.1 white-space</h4><ul>
<li>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">white-space</span>:normal ；默认处理方式</span><br><span class="line"></span><br><span class="line">white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。</span><br></pre></td></tr></table></figure>

<h4 id="4-2-text-overflow-文字溢出"><a href="#4-2-text-overflow-文字溢出" class="headerlink" title="4.2 text-overflow 文字溢出"></a>4.2 text-overflow 文字溢出</h4><ul>
<li>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">text-overflow</span> : clip ；不显示省略标记（...），而是简单的裁切 </span><br><span class="line"></span><br><span class="line">text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）</span><br></pre></td></tr></table></figure>

<p><strong>「注意」</strong>：</p>
<p>一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<h4 id="4-3-总结三步曲"><a href="#4-3-总结三步曲" class="headerlink" title="4.3 总结三步曲"></a>4.3 总结三步曲</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1. 先强制一行内显示文本*/</span></span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line"><span class="comment">/*2. 超出的部分隐藏*/</span></span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="comment">/*3. 文字用省略号替代超出的部分*/</span></span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/28/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Emmet语法学习</title>
    <url>/2021/09/21/Emmet%E8%AF%AD%E6%B3%95%EF%BC%88vscode%E8%87%AA%E5%B8%A6%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Emmet语法（vscode自带）"><a href="#Emmet语法（vscode自带）" class="headerlink" title="Emmet语法（vscode自带）"></a>Emmet语法（vscode自带）</h1><h2 id="一、快速生成HTML结构语法"><a href="#一、快速生成HTML结构语法" class="headerlink" title="一、快速生成HTML结构语法"></a>一、快速生成HTML结构语法</h2><p>1、生成标签，输入div 按tab键，快速生成标签</p>
<p>2、div*5 生成5个div标签</p>
<p>3、父子级关系标签用&gt; ，    如ul&gt;li</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4、兄弟（并列）关系用+，如div+p</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5、生成带类名和id的标签直接写id（默认div标签）如.demo或#demo    </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.id </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">#demo</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">p.demo	指定标签则前面加上限制标签即可</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">ul&gt;li.demo</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6、使用$自增符号，生成多个有顺序的类名</p>
<p>（应该是把$符号变为对应数字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">p.demo$*5</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;demo5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>7、用{}中输入，指定标签中的文本内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">div&#123;text&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">div&#123;text$&#125;*5</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>text1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>text2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>text3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>text4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>text5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、快速生成CSS结构语法"><a href="#二、快速生成CSS结构语法" class="headerlink" title="二、快速生成CSS结构语法"></a>二、快速生成CSS结构语法</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">输入tac补全成<span class="attribute">text-align</span>: center;</span><br><span class="line">输入ti补全成<span class="attribute">text-indent</span>: ;</span><br><span class="line">输入w100补全成<span class="attribute">width</span>: <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>Emmet语法</tag>
      </tags>
  </entry>
  <entry>
    <title>js基础知识笔记</title>
    <url>/2021/10/10/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。</p>
<h4 id="三种方式转换为字符串型"><a href="#三种方式转换为字符串型" class="headerlink" title="三种方式转换为字符串型"></a>三种方式转换为字符串型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>; alert(num.toString());</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>; alert(<span class="built_in">String</span>(num));</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>; alert(num+“我是字符串”);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>toString() 和 String() 使用方式不一样</p>
</li>
<li><p>三种转换方式，我们更喜欢用第三种加号拼接字符串转换方式，这一方式也称为隐士转换</p>
</li>
</ul>
<h2 id="转换为数字型"><a href="#转换为数字型" class="headerlink" title="转换为数字型"></a>转换为数字型</h2><table>
<thead>
<tr>
<th>方式</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>parselnt(string)函数</td>
<td>将string类型转成<strong>整数</strong>数值型</td>
<td>parselnt(‘78’)</td>
</tr>
<tr>
<td>parseFloat(string)函数</td>
<td>将string类型转成<strong>浮点数</strong>数值型</td>
<td>parseFloat(‘78.21’)</td>
</tr>
<tr>
<td>Number()强制转换函数</td>
<td>将string类型转换为<strong>数值型</strong></td>
<td>Number(‘12’)</td>
</tr>
<tr>
<td>js 隐式转换(- * /)</td>
<td>利用算术运算<strong>隐式转换为数值型</strong></td>
<td>‘12’-0</td>
</tr>
</tbody></table>
<ul>
<li>注意 parseInt 和 parseFloat ，这两个是重点</li>
<li>隐式转换是我们在进行算数运算的时候，JS自动转换了数据类型</li>
</ul>
<h2 id="转换为布尔型"><a href="#转换为布尔型" class="headerlink" title="转换为布尔型"></a>转换为布尔型</h2><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>案例</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean()函数</td>
<td>其他类型转成布尔值</td>
<td>Boolean(‘true’);</td>
</tr>
</tbody></table>
<ul>
<li>代表空，否定的值会被转换为false，如 ’ ’ , 0, NaN , null , undefined</li>
<li>其余的值都会被被转换为true</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>1、前置递增运算符<br>++num             （num = num + 1）</p>
<p>使用口诀:先自加，后返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert (++num + <span class="number">10</span>); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>先自加 10+1=11，返回11，此时num=11</p>
<p>2、后置递增运算符🔥<br>num ++             （num = num +1）</p>
<p>使用口诀:先返回原值，后自加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">alert(<span class="number">10</span> + num++); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<ul>
<li>单独使用时，运行结果相同；与其他代码联用时，执行结果会不同</li>
<li>开发时，大多使用后置递增/减，并且代码独占一行</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="===== 小结"></a>===== 小结</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>赋值</td>
<td>把右边给左边</td>
</tr>
<tr>
<td>==</td>
<td>判断</td>
<td>判断两边值是否相等(注意此时有隐士转换)</td>
</tr>
<tr>
<td>===</td>
<td>全等</td>
<td>判断两边的值和数据类型是否完全相同</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">18</span> == <span class="string">&#x27;18&#x27;</span>);		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">18</span> === <span class="string">&#x27;18&#x27;</span>);		<span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h2 id="短路运算-逻辑中断"><a href="#短路运算-逻辑中断" class="headerlink" title="短路运算(逻辑中断)"></a>短路运算(逻辑中断)</h2><p>​        短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值</p>
<h3 id="①逻辑与"><a href="#①逻辑与" class="headerlink" title="①逻辑与"></a>①逻辑与</h3><ul>
<li><p>语法：表达式1 &amp;&amp; 表达式2</p>
</li>
<li><p>如果结果值为真，则返回为真的表达式</p>
</li>
<li><p>如果结果值为假，则返回为假的表达式</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> &amp;&amp; <span class="number">456</span>);   <span class="comment">//456 	true&amp;&amp;true=true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> &amp;&amp; <span class="number">456</span>);     <span class="comment">//0		false&amp;&amp;true=false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> &amp;&amp; <span class="number">456</span> &amp;&amp; <span class="number">789</span>);  <span class="comment">//789		</span></span><br></pre></td></tr></table></figure>

<h3 id="②逻辑或"><a href="#②逻辑或" class="headerlink" title="②逻辑或"></a>②逻辑或</h3><ul>
<li><p>语法：表达式1 || 表达式2</p>
</li>
<li><p>有真，则返回第一个为真的表达式</p>
</li>
<li><p>所有表达式为假则返回假的表达式</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> || <span class="number">456</span>); <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> || <span class="number">456</span>);   <span class="comment">//456</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> || <span class="number">456</span> || <span class="number">789</span>);  <span class="comment">//123</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> || num++);</span><br><span class="line"><span class="comment">// 先返回在加，相当于 (123 || 0)</span></span><br><span class="line"><span class="built_in">console</span>.log(num);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h2 id="「运算符优先级」"><a href="#「运算符优先级」" class="headerlink" title="「运算符优先级」"></a><strong>「运算符优先级」</strong></h2><table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="left">运算符</th>
<th align="left">顺序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left">小括号</td>
<td align="left">()</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">一元运算符</td>
<td align="left">! ++ –</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">算数运算符</td>
<td align="left">先* / % 后+ -</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">关系运算符</td>
<td align="left">&gt; &gt;= &lt; &lt;=</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">相等运算符</td>
<td align="left">==  !=   === !==</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">逻辑运算符</td>
<td align="left">先&amp;&amp; 后||</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left">赋值运算符</td>
<td align="left">=</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left">逗号运算符</td>
<td align="left">,</td>
</tr>
</tbody></table>
<h2 id="「三元表达式」"><a href="#「三元表达式」" class="headerlink" title="「三元表达式」"></a><strong>「三元表达式」</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</span></span><br><span class="line">表达式<span class="number">1</span> ? 表达式<span class="number">2</span> : 表达式<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ul>
<li>利用new关键字创建数组；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = <span class="keyword">new</span> <span class="built_in">Array</span>([n]);<span class="comment">//[]代表可选 若写n，则代表数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//创建了一个名为 arr 的空数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用数组字面量创建数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span> 数组名 = [];<span class="comment">//若写n，则代表数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="comment">//3. 声明数组并赋值称为数组的初始化</span></span><br><span class="line"><span class="keyword">var</span> arr =[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;fan&#x27;</span>,<span class="literal">true</span>,<span class="number">17.5</span>];<span class="comment">//数组中可以存放任意类型的数据</span></span><br></pre></td></tr></table></figure>

<h2 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h2><h5 id="①通过修改-length-长度新增数组元素"><a href="#①通过修改-length-长度新增数组元素" class="headerlink" title="①通过修改 length 长度新增数组元素"></a>①通过修改 length 长度新增数组元素</h5><ul>
<li>可以通过修改 length 长度来实现数组扩容的目的</li>
<li>length 属性是可读写的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line">arr.length = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">6</span>]);</span><br></pre></td></tr></table></figure>

<p>其中索引号是 4，5，6 的空间没有给值，就是声明变量未给值，默认值就是 undefined</p>
<h5 id="②通过修改数组索引新增数组元素"><a href="#②通过修改数组索引新增数组元素" class="headerlink" title="②通过修改数组索引新增数组元素"></a>②通过修改数组索引新增数组元素</h5><ul>
<li><p>可以通过修改数组索引的方式追加数组元素</p>
</li>
<li><p>不能直接给数组名赋值，否则会覆盖掉以前的数据</p>
</li>
<li><p>这种方式也是我们最常用的一种方式</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;hotpink&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="「1-函数的概念」"><a href="#「1-函数的概念」" class="headerlink" title="「1. 函数的概念」"></a><strong>「1. 函数的概念」</strong></h3><p>封装了一段可被重复调用执行的代码块，通过函数可以实现大量代码的重复使用。函数是一种数据类型。</p>
<h3 id="「2-函数的使用」"><a href="#「2-函数的使用」" class="headerlink" title="「2. 函数的使用」"></a><strong>「2. 函数的使用」</strong></h3><h5 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h5><p>​            1. 通过function关键字定义函数 – 命名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//函数体代码  </span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 1.1 function 是声明函数的关键字，必须小写</span></span><br><span class="line">  <span class="comment">// 1.2 函数名 命名为动词形式 例: getSum</span></span><br></pre></td></tr></table></figure>
<p>​            2.通过函数表达式定义函数 —匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 2.1 fn是变量名，不是函数名</span></span><br><span class="line"><span class="comment">// 2.2 fn是变量，只不过变量存储的是函数</span></span><br><span class="line"><span class="comment">// 2.3 函数表达式创建的函数可以通过 变量名(); 来调用</span></span><br><span class="line"><span class="comment">// 2.4 函数表达式也可以定义形参和调用传入实参。</span></span><br></pre></td></tr></table></figure>

<p>​            3.匿名函数使用的第2种方式–匿名函数自调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="number">123</span>);  </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数名();// 函数声明后调用才会执行函数体代码</span><br></pre></td></tr></table></figure>

<h5 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h5><ul>
<li>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例用封装函数计算1-100累加和*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sumNum = <span class="number">0</span>; <span class="comment">// 准备一个变量，保存累加和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">      sumNum += i; <span class="comment">// 把每个数值 都累加 到变量中</span></span><br><span class="line">    &#125;</span><br><span class="line">      alert(sumNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">getSum();</span><br></pre></td></tr></table></figure>

<h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>有的时候，我们会希望函数将值返回给调用者，此时通过使用 return 语句就可以实现。</p>
<p>return 语句的语法格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ 声明函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名（）</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>  需要返回的值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名();    <span class="comment">// 此时调用函数就可以得到函数体内return 后面的值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在使用 return 语句时，函数会停止执行，并返回指定的值</li>
<li>如果函数没有 return ，返回的值是 undefined</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">sum();      <span class="comment">// 此时 sum 的值就等于666，因为 return 语句会把自身后面的值返回给调用者 </span></span><br></pre></td></tr></table></figure>

<h2 id="return-终止函数"><a href="#return-终止函数" class="headerlink" title="return 终止函数"></a>return 终止函数</h2><p>return 语句之后的代码不被执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1，num2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2; <span class="comment">// 注意：return 后的代码不执行</span></span><br><span class="line">    alert(<span class="string">&#x27;我不会被执行，因为前面有 return&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> resNum = add(<span class="number">21</span>,<span class="number">6</span>); <span class="comment">// 调用函数，传入两个实参，并通过 resNum 接收函数返回值</span></span><br><span class="line">alert(resNum);          <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<h2 id="return-的返回值"><a href="#return-的返回值" class="headerlink" title="return 的返回值"></a>return 的返回值</h2><p>return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1，num2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="keyword">return</span> num1,num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> resNum = add(<span class="number">21</span>,<span class="number">6</span>); <span class="comment">// 调用函数，传入两个实参，并通过 resNum 接收函数返回值</span></span><br><span class="line">alert(resNum);          <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h2><ol>
<li>当不确定有多少个参数传递的时候，可以用 arguments 来获取。</li>
<li>JS中arguments实际上它是当前函数的一个内置对象。</li>
<li>所有函数都内置了一个 arguments 对象,arguments 对象中存储了传递的所有实参。</li>
<li>arguments展示形式是一个伪数组，因此可以进行遍历。</li>
</ol>
<ul>
<li><p>伪数组具有以下特点：</p>
</li>
<li><ul>
<li>具有length属性</li>
<li>按索引方式存储数据</li>
<li>不具有数组的push，pop等方法</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//arguments 里面存储了所有传递过来的实参</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);<span class="comment">// [1,2,3...]</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 3</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//我们可以按照数组的方式 遍历argument  </span></span><br><span class="line"> &#125;</span><br><span class="line"> fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用伪数组 实现求最大值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> max = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">arguments</span>[i] &gt; <span class="built_in">arguments</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">       max = <span class="built_in">arguments</span>[i];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> result = getMax(<span class="number">1</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">5</span>,<span class="number">85</span>)</span><br><span class="line"> colsole.log(result);</span><br></pre></td></tr></table></figure>



<p>全局变量：</p>
<ul>
<li><p>在全局作用域下 var 声明的变量 是全局变量。</p>
</li>
<li><p>在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</p>
</li>
</ul>
<p>局部变量：</p>
<ul>
<li>在函数内部 var 声明的变量是局部变量，函数的<strong>形参</strong>实际上就是<strong>局部变量</strong>。</li>
<li>只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</li>
</ul>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p><strong>「预解析相关概念」</strong>JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分为两步:预解析和代码执行。</p>
<ul>
<li><strong>「预解析」</strong>在当前作用域下，JS代码执行之前，浏览器会默认把带有 var 和 function声明的变量在内存中进行提前声明或定义。</li>
<li><strong>「代码执行」</strong>从上往下执行JS语句</li>
</ul>
<p>预解析会把变量和函数的声明在代码执行之前完成，预解析也叫做变量、函数提升。</p>
<p><strong>「变量预解析(变量提升)」</strong> 变量的<strong>声明</strong>会被提升到当前作用域的最上面，变量的<strong>赋值不提升</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">// 结果是多少？</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;      <span class="comment">// ？</span></span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">// 结果是 undefined</span></span><br><span class="line">num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//结果: undefined</span></span><br><span class="line"><span class="comment">//注意: 变量提升只提升声明，不提升赋值。</span></span><br></pre></td></tr></table></figure>

<p><strong>「函数预解析(函数提升)」</strong> 函数的声明会被提升到当前作用域的最上面，但是<strong>不会调用函数</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  fn();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;打印&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结果: 控制台打印字符串 --- &quot;打印&quot;</span></span><br><span class="line"><span class="comment">//相当于以下</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;打印&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fn();		<span class="comment">//此时才调用函数</span></span><br><span class="line">  <span class="comment">//注意: 函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！</span></span><br></pre></td></tr></table></figure>

<p><strong>「函数表达式声明函数问题」</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用</span></span><br><span class="line">  fn();</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;想不到吧&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//结果:报错提示 &quot;fn is not a function&quot;</span></span><br><span class="line">  <span class="comment">//相当于执行以下代码</span></span><br><span class="line"> <span class="keyword">var</span> fn;</span><br><span class="line"> fn();			<span class="comment">//fn()未被定义为函数，报错</span></span><br><span class="line"> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;想不到吧&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  解释: 该段代码执行之前，会做变量声明提升，fn在提升之后的值</span><br><span class="line">        是<span class="literal">undefined</span>;而fn调用是在fn被赋值为函数体之前，</span><br><span class="line">        此时调用的fn未赋值为函数，所以无法被调用而出错</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="预解析案例"><a href="#预解析案例" class="headerlink" title="预解析案例"></a>预解析案例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习1</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">fun();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);	<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终结果是 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于以下</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">    num = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="number">10</span>;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<p>上面PS：<strong>函数声明提升，函数内的局部变量声明也在函数内部提升</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习2</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);		<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);		<span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">// 最终结果是 undefined 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于以下</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">   	num = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br><span class="line">num = <span class="number">10</span>;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预解析案例3</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">18</span>;</span><br><span class="line">  f1();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于执行了以下操作 结果为 undefined 9</span></span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    b = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    a = <span class="string">&#x27;123&#x27;</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">  a = <span class="number">18</span>;</span><br><span class="line">  f1();  </span><br><span class="line">  <span class="comment">//undefined 9</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预解析案例3</span></span><br><span class="line">  f1();</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = b = c = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//相当于执行了以下操作 结果为 9 9 9 9 9 &quot;报错--a is not defined&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    a = b = c = <span class="number">9</span>;<span class="comment">//相当于 var a = 9; b=9; c=9; b和c 直接赋					值，没有var声明，当全局变量看。</span></span><br><span class="line">				   <span class="comment">//差异：集体声明 var a = 9,b = 9, c = 9;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">  &#125;</span><br><span class="line">  f1();</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="built_in">console</span>.log(a);	<span class="comment">//此时a为局部变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注意：var-a-b-c-9"><a href="#注意：var-a-b-c-9" class="headerlink" title="注意：var a = b = c = 9;"></a>注意：<strong>var a = b = c = 9;</strong></h4><p>​        <strong>相当于 var a = 9; b=9; c=9;</strong></p>
<p>​        <strong>b和c 直接赋值，未在函数内部var声明，则为全局变量，而a为布局变量。</strong></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a><strong>对象</strong></h2><h3 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h3><p><strong>「对象」</strong>在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p>
<ul>
<li><p>对象是由属性和方法组成的</p>
</li>
<li><ul>
<li>属性：事物的特征，在对象中用属性来表示（常用名词）</li>
<li>方法：事物的行为，在对象中常用方法来表示（常用动词）</li>
</ul>
</li>
</ul>
<p><strong>「为什么需要对象」</strong></p>
<ul>
<li>保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组，如果保存一个的完整信息呢？</li>
<li>为了更好地存储一组数据，对象应用而生；对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;fan&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sex&quot;</span>:<span class="string">&quot;male&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="string">&quot;height&quot;</span>:<span class="number">155</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象的三种方式"><a href="#创建对象的三种方式" class="headerlink" title="创建对象的三种方式"></a>创建对象的<strong>三种</strong>方式</h3><p><strong>「1. 利用字面量创建对象」</strong>使用对象字面量创建对象：</p>
<ul>
<li>就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示<br>-<code>键</code>：相当于属性名<br>-<code>值</code>：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// star 就是创建的对象</span></span><br><span class="line"><span class="keyword">var</span> star = &#123;		<span class="comment">//对象-star</span></span><br><span class="line">  <span class="attr">name</span> : <span class="string">&#x27;pink&#x27;</span>,	<span class="comment">//属性-name</span></span><br><span class="line">  <span class="attr">age</span> : <span class="number">18</span>,</span><br><span class="line">  <span class="attr">sex</span> : <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHi</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;大家好啊&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象的使用</p>
</li>
<li><ul>
<li>对象的属性：对象中<code>存储具体数据</code>的“键值对”中的键称为对象的属性，即对象中存储具体数据的项。</li>
<li>对象的方法：对象中<code>存储函数</code>的“键值对”中的“键”称为对象的方法，即对象中存储函数的项。</li>
<li>访问对象的属性：对象里面的属性调用：<code>对象.属性名</code>；对象里面属性的另一种调用方式：对象[‘属性名’],注意方括号里面的属性必须加上引号。</li>
<li>调用对象的方法:<code>对象.方法名();</code></li>
<li>变量、属性、函数、方法总结：<br><code>①变量</code>：单独声明赋值，单独存在<br><code>②属性</code>:对象里面的变量称为属性，不需要声明，用来描述该对象的特征。<br><code>③方法</code>：方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器。对象里面的函数称为方法，方法不需要声明，使用”对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。<br><code>④函数</code>:单独存在的，通过”函数名()”的方式就可以调用。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(star.name)     <span class="comment">// 调用名字属性</span></span><br><span class="line"><span class="built_in">console</span>.log(star[<span class="string">&#x27;name&#x27;</span>])  <span class="comment">// 调用名字属性</span></span><br><span class="line">star.sayHi();</span><br></pre></td></tr></table></figure>

<p><strong>「2. 利用new Object创建对象」</strong></p>
<ul>
<li>创建空对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</span></span><br><span class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> <span class="built_in">Object</span>();  </span><br></pre></td></tr></table></figure>

<ul>
<li>给空对象添加属性和方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">通过对象操作属性和方法的方式，来为对象增加属性和方法</span><br><span class="line">andy.name = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">andy.age = <span class="number">18</span>; <span class="comment">// andy.age = 19修改对象属性</span></span><br><span class="line">andy.sex = <span class="string">&#x27;男；// andy.phoneNum = 110 添加属性</span></span><br><span class="line"><span class="string">andy.sayHi = function() &#123;</span></span><br><span class="line"><span class="string">  alert(&#x27;</span>大家好<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">andy.sayHi();调用对象的方法 //第二种写法 obj[&#x27;</span>sayHi<span class="string">&#x27;]();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Object()第一个字母大写；</span></span><br><span class="line"><span class="string">//new Object() 需要new关键字，使用的格式:对象.属性 = 值</span></span><br></pre></td></tr></table></figure>

<p><strong>「3. 利用构造函数创建对象」</strong></p>
<p><code>构造函数</code>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值,它总与new运算符一起使用，我们可以把对象中一些公共的属性和方法抽出来，然后封装到这个函数里面。</p>
<ul>
<li>构造函数的封装格式：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 构造函数名(<span class="params">形参<span class="number">1</span>，形参<span class="number">2</span>，形参<span class="number">3.</span>..</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.属性名<span class="number">1</span> = 参数<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.属性名<span class="number">2</span> = 参数<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">this</span>.属性名<span class="number">3</span> = 参数<span class="number">3</span>;</span><br><span class="line">  <span class="built_in">this</span>.方法名 = 函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数的调用格式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> 对象名 = <span class="keyword">new</span> 构造函数名(实参<span class="number">1</span>，实参<span class="number">2</span>，实参<span class="number">3</span>);</span><br><span class="line">  <span class="comment">// 以上代码中，obj即接收到构造函数创建出来的对象。</span></span><br><span class="line">  注意事项：</span><br><span class="line">    <span class="number">1.</span>构造函数约定首字母大写</span><br><span class="line">    <span class="number">2.</span>函数内的属性和方法前面需要添加<span class="built_in">this</span>，表示当前对象的属性和方法</span><br><span class="line">    <span class="number">3.</span>构造函数中不需要retrun返回结果</span><br><span class="line">    <span class="number">4.</span>但我们创建对象的时候，必须用<span class="keyword">new</span>来调用构造函数</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">uname,age,sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    <span class="built_in">this</span>.sing = <span class="function"><span class="keyword">function</span>(<span class="params">sang</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(sang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ldh) <span class="comment">// object对象，调用函数返回的是对象</span></span><br><span class="line"><span class="built_in">console</span>.log(ldh.name);</span><br><span class="line"><span class="built_in">console</span>.log(ldh[<span class="string">&#x27;sex&#x27;</span>]);</span><br><span class="line">ldh.sing(<span class="string">&#x27;冰雨&#x27;</span>);<span class="comment">//把冰雨传给了sang</span></span><br><span class="line"><span class="comment">//结果显示 object 刘德华 男 冰雨</span></span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男性&#x27;</span>);<span class="comment">//若第二次调用构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> ldh)</span><br><span class="line"><span class="built_in">console</span>.log(ldh.name);</span><br><span class="line"><span class="built_in">console</span>.log(ldh[<span class="string">&#x27;sex&#x27;</span>]);</span><br><span class="line">ldh.sing(<span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="comment">//结果显示 object 刘德华 男 abc</span></span><br><span class="line"><span class="comment">//前面第一次构造的保持不变</span></span><br><span class="line">    <span class="number">1.</span>其他：构造函数如Stars(),抽取了对象的公共部分，封装到了函数里面，它泛指某一大类(<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    2.创建对象，如<span class="title">new</span> <span class="title">Stars</span>()</span>;特指某一个，利用<span class="keyword">new</span>关键字创建对象的过程，我们也称为对象实例化</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>new关键字的作用(面试题)</strong></p>
</li>
<li><ul>
<li>1.在构造函数代码开始执行之前，创建一个空对象；</li>
<li>2.修改this的指向，把this指向创建出来的空对象；</li>
<li>3.执行构造函数内的代码，给这个新对象添加属性和方法</li>
<li>4.在函数完成之后，返回这个创建出来的新对象(所以构造函数里面不需要return)</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//******以下暂未理解*****</span></span><br><span class="line"><span class="comment">// 工厂函数创建对象 这个把创建好的对象返回给函数调用处</span></span><br><span class="line"><span class="comment">//构造函数createPerson</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="comment">//创建新对象</span></span><br><span class="line">    person.name = name;</span><br><span class="line">    person.age = age;</span><br><span class="line">    person.job = job;</span><br><span class="line">    person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello,everyBody&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">var</span> p1 = createPerson(<span class="string">&#x27;张三&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;actor&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>...in 语句用于对数组或者对象的属性进行循环操作。</span><br><span class="line"></span><br><span class="line">  <span class="comment">//其语法如下：</span></span><br><span class="line">  <span class="keyword">for</span> (变量 <span class="keyword">in</span> 对象名字) &#123;</span><br><span class="line">      <span class="comment">// 在此执行代码</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);      <span class="comment">// 这里的 k 是属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[k]); <span class="comment">// 这里的 obj[k] 是属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        遍历对象案例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;秦&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);</span><br><span class="line"><span class="built_in">console</span>.log(obj.sex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//for in 遍历我们的对象</span></span><br><span class="line"><span class="comment">//for (变量 in 对象)&#123;&#125;</span></span><br><span class="line"><span class="comment">//我们使用for in 里面的变量 我们喜欢写k 或者key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k); <span class="comment">// k 变量 输出得到的是属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[k]); <span class="comment">// obj[k] 得到的是属性值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为 秦 18 男 name 秦 age 18 sex 男 fn ƒ () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p><strong>「内置对象」</strong>JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象<br>前面两种对象是JS基础内容，属于ECMAScript;第三个浏览器对象属于JS独有的，JS API讲解内置对象就是指js语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而非必要的功能(属性和方法),内置对象最大的优点就是帮助我们快速开发。</p>
<p><strong>「查文档」</strong>学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习。<br><code>MDN:</code><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p><strong>「Math对象」</strong>不是构造函数，它具有数学常数和函数的属性和方法，跟数学相关。</p>
<table>
<thead>
<tr>
<th align="left">属性、方法名</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Math.PI</td>
<td align="left">圆周率</td>
</tr>
<tr>
<td align="left">Math.floor()</td>
<td align="left">向下取整</td>
</tr>
<tr>
<td align="left">Math.ceil()</td>
<td align="left">向上取整</td>
</tr>
<tr>
<td align="left">Math.round()</td>
<td align="left">四舍五入版 就近取整  注意 -3.5  结果是  -3</td>
</tr>
<tr>
<td align="left">Math.abs()</td>
<td align="left">绝对值</td>
</tr>
<tr>
<td align="left">Math.max()/Math.min()</td>
<td align="left">求最大和最小值</td>
</tr>
<tr>
<td align="left">Math.random()</td>
<td align="left">获取范围在[0,1)内的随机值</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//- 获取指定范围的随机整数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getRandom</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h3><p>  Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</p>
<ul>
<li><p><strong>使用Date实例化日期对象</strong></p>
</li>
<li><ul>
<li><strong>获取当前时间必须实例化</strong></li>
<li>获取指定时间的日期对象</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> future = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2020/10/1&#x27;</span>)</span><br><span class="line"><span class="comment">// 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>续上</p>
</li>
<li><ul>
<li>使用Date实例的方法和属性</li>
<li>注意！！：getMonth()方法获取到的<strong>月份 + 1 = 当月</strong></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>getFullYear()</td>
<td>获取当年</td>
<td>dObj.getFullYear()</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取当月(0-11)</td>
<td>dObj.getMonth()</td>
</tr>
<tr>
<td>getDate</td>
<td>获取当天日期</td>
<td>dObj.getDate()</td>
</tr>
<tr>
<td>getDay()</td>
<td>获取星期几(周日0到周六6)</td>
<td>dObj.getDay()</td>
</tr>
<tr>
<td>getHours()</td>
<td>获取当前小时</td>
<td>dObj.getHours()</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取当前小时</td>
<td>dObj.getMinutes()</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取当前秒钟</td>
<td>dObj.gerSeconds()</td>
</tr>
</tbody></table>
<ul>
<li></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数常用写法 数字型或者字符串型 &#x27;2019-10-1 8:8:8&#x27;</span></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//日期格式化</span></span><br><span class="line"><span class="comment">// 格式化日期 年 月 日</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date.getFullYear()); <span class="comment">//返回当前日期的年 2020</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getMonth() + <span class="number">1</span>); <span class="comment">//月份 返回的月份小1个月，记得月份加1呦</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getDate()); <span class="comment">//返回的是 几号</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getDay()); <span class="comment">//周一返回的是1 周六返回的是6 周日返回的是0</span></span><br><span class="line"><span class="comment">//我们写一个 完整的年月日</span></span><br><span class="line"><span class="keyword">var</span> year = date.getFullYear();</span><br><span class="line"><span class="keyword">var</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> dates = date.getDate();</span><br><span class="line"><span class="keyword">var</span> day = date.getDay();</span><br><span class="line"><span class="keyword">if</span> (day == <span class="number">0</span>) &#123;</span><br><span class="line">    day = <span class="string">&quot;星期日&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;今天是&quot;</span> + year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + dates + <span class="string">&quot;日&quot;</span> + <span class="string">&#x27;星期&#x27;</span> + day);</span><br><span class="line"><span class="comment">//格式化日期 时分秒</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(date.getHours()); <span class="comment">//时</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getMinutes()); <span class="comment">//分</span></span><br><span class="line"><span class="built_in">console</span>.log(date.getSeconds()); <span class="comment">// </span></span><br><span class="line"><span class="comment">//封装一个函数返回当前的 时 分 秒 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTimer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> h = time.getHours();</span><br><span class="line">    <span class="keyword">var</span> h = h &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + h : h</span><br><span class="line">    <span class="keyword">var</span> m = time.getMinutes();</span><br><span class="line">    <span class="keyword">var</span> m = m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + m : m</span><br><span class="line">    <span class="keyword">var</span> s = time.getSeconds();</span><br><span class="line">    <span class="keyword">var</span> s = s &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + s : s;</span><br><span class="line">    <span class="keyword">return</span> h + <span class="string">&quot;:&quot;</span> + h + <span class="string">&quot;:&quot;</span> + s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;现在的时间是&#x27;</span> + getTimer());</span><br></pre></td></tr></table></figure>

<ul>
<li><code>获取Date日期总的毫秒数(时间戳)</code></li>
<li>getTime() 返回距 1970 年 1 月 1 日(世界标准世界)之间的毫秒数：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化Date对象</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="comment">// 1. 用于获取对象的原始值</span></span><br><span class="line"><span class="built_in">console</span>.log(now.valueOf()) </span><br><span class="line"><span class="built_in">console</span>.log(now.getTime()) </span><br><span class="line"><span class="comment">// 2. 简单写可以这么做 (最常用的)</span></span><br><span class="line"><span class="keyword">var</span> now = + <span class="keyword">new</span> <span class="built_in">Date</span>();   </span><br><span class="line"><span class="comment">// 3. HTML5中提供的方法，有兼容性问题</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">倒计时案例 ：</span><br><span class="line">  <span class="number">1.</span>输入的时间减去现在的时间就是剩余的时间，即倒计时。</span><br><span class="line">  <span class="number">2.</span>用时间戳来做，用户输入时间总的毫秒数减去现在时间的总的毫秒数，</span><br><span class="line">   得到的就是剩余时间的毫秒数</span><br><span class="line">  <span class="number">3.</span>把剩余时间总的毫秒数转换为天、时、分、秒  (时间戳转换时分秒)</span><br><span class="line">    转换公式如下：</span><br><span class="line">    d = <span class="built_in">parseInt</span>(总秒数/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>) <span class="comment">// 计算天数</span></span><br><span class="line">    h = <span class="built_in">parseInt</span>(总秒数/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>) <span class="comment">// 计算小时</span></span><br><span class="line">    m = <span class="built_in">parseInt</span>(总秒数/<span class="number">60</span>%<span class="number">60</span>);   <span class="comment">// 计算分钟  </span></span><br><span class="line">    s = <span class="built_in">parseInt</span>(总秒数%<span class="number">60</span>);      <span class="comment">// 计算当前秒数 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------日期倒计时案例 封装函数实现----------------</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">countDown</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nowTime = +<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 返回的是当前时间总的毫秒数</span></span><br><span class="line">        <span class="keyword">var</span> inputTime = +<span class="keyword">new</span> <span class="built_in">Date</span>(time); <span class="comment">// 返回的是用户输入时间总的毫秒数</span></span><br><span class="line">        <span class="keyword">var</span> times = (inputTime - nowTime) / <span class="number">1000</span>; <span class="comment">// times是剩余时间总的秒数</span></span><br><span class="line">        <span class="keyword">var</span> d = <span class="built_in">parseInt</span>(times / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>); <span class="comment">// 天</span></span><br><span class="line">        d = d &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + d : d;</span><br><span class="line">        <span class="keyword">var</span> h = <span class="built_in">parseInt</span>((times / <span class="number">60</span> / <span class="number">60</span>) % <span class="number">24</span>); <span class="comment">//时</span></span><br><span class="line">        h = h &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + h : h;</span><br><span class="line">        <span class="keyword">var</span> m = <span class="built_in">parseInt</span>((times / <span class="number">60</span>) % <span class="number">60</span>); <span class="comment">// 分</span></span><br><span class="line">        m = m &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + m : m;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(times % <span class="number">60</span>); <span class="comment">// 当前的秒</span></span><br><span class="line">        s = s &lt; <span class="number">10</span> ? <span class="string">&quot;0&quot;</span> + s : s;</span><br><span class="line">        <span class="keyword">return</span> d + <span class="string">&quot;天&quot;</span> + h + <span class="string">&quot;时&quot;</span> + m + <span class="string">&quot;分&quot;</span> + s + <span class="string">&quot;秒&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(countDown(<span class="string">&quot;2020-10-1 18:00:00&quot;</span>));</span><br><span class="line">      <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      <span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure>

<h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p><strong>「创建数组的两种方式」</strong></p>
<ul>
<li><p><strong>1. 字面量方式</strong><code>var arr = [1,&quot;test&quot;,true];</code></p>
</li>
<li><p><strong>2. 实例化数组对象 new Array()</strong>    <code>var arr = new Array();</code></p>
</li>
<li><ul>
<li>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</li>
<li>如果只传入一个参数(数字)，则参数规定了数组的长度。</li>
<li>如果传入了多个参数，则参数称为数组的元素。</li>
</ul>
</li>
</ul>
<p><strong>「检测是否为数组」</strong></p>
<ul>
<li><p>**1. instanceof 运算符    **(注意这个是运算符)</p>
</li>
<li><ul>
<li><p>instanceof 可以判断一个对象是否是某个构造函数的实例</p>
</li>
<li><p>A  instanceof  B     </p>
</li>
<li><p>（1）A是否是B的实例</p>
<p>（2）A是否是B子类的实例</p>
<p>（3）A是否是B接口实现类的实例</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true	</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>2. Array.isArray()</strong></p>
</li>
<li><ul>
<li>Array.isArray()用于判断一个对象是否为数组</li>
<li>isArray() 是 HTML5 中提供的方法</li>
<li>Array.isArray(arr)       arr是否是Array的实例</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(obj));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>3. 注意 typeof用法</strong></p>
</li>
<li><ul>
<li>typeof 用于判断变量的类型</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr) <span class="comment">// object 对象arr是构造函数的实例因此是对象数据类型</span></span><br></pre></td></tr></table></figure>

<p><strong>「添加删除数组元素的方法」</strong></p>
<ul>
<li>数组中有进行增加、删除元素的方法，部分方法如下表👇</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th align="center"><strong>说明</strong></th>
<th><strong>返回值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>push(参数1…)</td>
<td align="center">末尾添加一个或多个元素，注意修改原数组</td>
<td>并返回新的长度</td>
</tr>
<tr>
<td>pop()</td>
<td align="center">删除数组最后一个元素</td>
<td>返回它删除的元素的值</td>
</tr>
<tr>
<td>unshift(参数1…)</td>
<td align="center">向数组的开头添加一个或更多元素，注意修改原数组</td>
<td>并返回新的长度</td>
</tr>
<tr>
<td>shift()</td>
<td align="center">删除数组的第一个元素，数组长度减1，无参数，修改原数组</td>
<td>并返回第一个元素</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="number">6</span>, <span class="number">7</span>)); <span class="comment">// 5 向数组末尾添加元素 返回新的长度</span></span><br><span class="line">arr.pop(); <span class="comment">//删除数组最后一个值并返回</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1,2,3,6]</span></span><br><span class="line"><span class="comment">// 向数组的开头添加元素并返回数组长度 </span></span><br><span class="line"><span class="built_in">console</span>.log(arr.unshift(<span class="number">9</span>,<span class="number">10</span>));<span class="comment">// 6 数组变为[10,1,2,3,6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.shift()); <span class="comment">//9 删除数组开头的元素并返回被删的值</span></span><br></pre></td></tr></table></figure>

<p><strong>「数组排序」</strong></p>
<ul>
<li>数组中有对数组本身排序的方法，部分方法如下表</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
<th align="left">是否修改原数组</th>
</tr>
</thead>
<tbody><tr>
<td align="left">reverse()</td>
<td align="left">颠倒数组中元素的顺序，无参数</td>
<td align="left">该方法会改变原来的数组 返回新数组</td>
</tr>
<tr>
<td align="left">sort()</td>
<td align="left">对数组的元素进行排序</td>
<td align="left">该方法会改变原来的数组 返回新数组</td>
</tr>
</tbody></table>
<p>注意：<strong>sort方法需要传入参数(函数)来设置按大小升序、降序排序</strong></p>
<ul>
<li>如果在sort中传入“function(a,b){ return a-b;}”，则为从小到大升序</li>
<li>如果在sort中传入“function(a,b){ return b-a;}”，则为从大到小降序</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 踩坑 数组sort()排序(冒泡排序) return a - b 则升序</span></span><br><span class="line"><span class="comment">// 写法固定 参考如下</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">13</span>,<span class="number">4</span>,<span class="number">77</span>,<span class="number">1</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1.reverse())<span class="comment">//[7, 1, 77, 4, 13]	颠倒顺序</span></span><br><span class="line">arr1.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;	<span class="comment">//创建函数</span></span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);	<span class="comment">//[1, 4, 7, 13, 77]</span></span><br></pre></td></tr></table></figure>

<p><strong>「数组索引方法」</strong></p>
<ul>
<li>数组中有获取数组指定元素索引值的方法，部分方法如下表</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>indexOf()</td>
<td>数组中查找给定元素的第一个索引</td>
<td>如果存在返回索引号，如果不存在，则返回-1</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>在数组的最后一个索引，从后向前索引</td>
<td>如果存在返回索引号，如果不存在，则返回-1</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 查找第一个元素2的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">2</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 查找最后一个元素1在数组中的最后的索引</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="number">1</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>「数组转换为字符串」</strong></p>
<ul>
<li>数组中有把数组转化为字符串的方法，部分方法如下表</li>
<li>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>toString()</td>
<td>把数组转换成字符串，逗号分隔每一项</td>
<td>返回一个字符串</td>
</tr>
<tr>
<td>join(‘分隔符’)</td>
<td>方法用于把数组中的所有元素转换为一个字符串</td>
<td>返回一个字符串</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = arr;</span><br><span class="line"><span class="keyword">var</span> str = arr.toString(); <span class="comment">// 将数组转换为字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//  1,2,3,4</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> str2 = arr2.join(<span class="string">&quot;|&quot;</span>);<span class="comment">//按照键入字符将数组转换为字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str2);<span class="comment">//  1|2|3|4</span></span><br></pre></td></tr></table></figure>

<p><strong>「其他方法」</strong></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>concat()</td>
<td>连接两个或多个数组 不影响原数组</td>
<td>返回一个新的数组</td>
</tr>
<tr>
<td>slice()</td>
<td>数组截取slice(begin,end)</td>
<td>返回被截取项目的新数组</td>
</tr>
<tr>
<td>splice()</td>
<td>数组删除splice(第几个开始要删除的个数)</td>
<td>返回被删除项目的新数组，这个会影响原数组</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = arr.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [1,2,3,4,5,6,7,8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//slice(begin,end) 相当于复制出来。是一种左闭右开区间 [1,3)</span></span><br><span class="line"><span class="comment">// 从索引1出开始截取，到索引3之前</span></span><br><span class="line"><span class="keyword">var</span> arr4 = arr.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr4); <span class="comment">// [2,3]</span></span><br><span class="line"><span class="comment">//splice()相当于剪切 </span></span><br><span class="line"><span class="keyword">var</span> arr5 = arr2.splice(<span class="number">0</span>, <span class="number">3</span>);	<span class="comment">//左闭右开</span></span><br><span class="line"><span class="built_in">console</span>.log(arr5); <span class="comment">// [5,6,7]</span></span><br><span class="line">   <span class="built_in">console</span>.log(arr2); <span class="comment">// [8]   splice()会影响原数组</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p><strong>「基本包装类型」</strong>为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。<br>  <code>基本包装类型就是把简单数据类型包装成为复杂数据类型</code>，这样基本数据类型就有了属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面代码有什么问题？</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;andy&#x27;</span>;			<span class="comment">//字符串类型</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>  按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 js 会把基本数据类型包装为复杂数据类型，相当于其执行过程如下 ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;andy&#x27;</span>);</span><br><span class="line"><span class="comment">// 2. 赋值给我们声明的字符变量</span></span><br><span class="line">str = temp;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str)	<span class="comment">//object</span></span><br><span class="line"><span class="comment">// 3. 销毁临时变量</span></span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>「字符串的不可变」</strong></p>
<ul>
<li>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</li>
<li>当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。</li>
<li>由于字符串的不可变，在<strong>「大量拼接字符串」</strong>的时候会有效率问题</li>
</ul>
<p><strong>「根据字符返回位置」</strong></p>
<ul>
<li>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">indexOf(‘要查找的字符’，开始的位置)</td>
<td align="left">返回指定内容在元字符串中的位置，如果找不到就返回-1，开始的位置是index索引号</td>
</tr>
<tr>
<td align="left">lastIndexOf()</td>
<td align="left">从后往前找，只找第一个匹配的</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;anndy&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&quot;d&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//指定从索引号为4的地方开始查找字符&quot;d&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.indexOf(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>)); <span class="comment">// -1	从4开始查找d</span></span><br><span class="line"><span class="built_in">console</span>.log(str.lastIndexOf(<span class="string">&quot;n&quot;</span>)); <span class="comment">// 2	但是索引是正的</span></span><br></pre></td></tr></table></figure>

<p>案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数</p>
<ol>
<li>先查找第一个o出现的位置</li>
<li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li>
<li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;oabcoefoxyozzopp&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> index = str.indexOf(<span class="string">&quot;o&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">  num++;</span><br><span class="line">  index = str.indexOf(<span class="string">&quot;o&quot;</span>, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;o出现的次数是: &#x27;</span> + num);<span class="comment">//o出现的次数是: 5</span></span><br></pre></td></tr></table></figure>

<p><strong>「根据位置返回字符」</strong></p>
<ul>
<li>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>charAt(index)</td>
<td>返回指定位置的字符(index字符串的索引号)</td>
<td>str.charAt(0)</td>
</tr>
<tr>
<td>charCodeAt(index)</td>
<td>获取指定位置处字符的ASCII码(index索引号)</td>
<td>str.charCodeAt(0)</td>
</tr>
<tr>
<td>str[index]</td>
<td>获取指定位置处字符</td>
<td>HTML,IE8+支持和charAt()等效</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据位置返回字符</span></span><br><span class="line"><span class="comment">// 1. charAt(index) 根据位置返回字符</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;andy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.charAt(<span class="number">3</span>)); <span class="comment">// y</span></span><br><span class="line"><span class="comment">// 遍历所有的字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str.charAt(i));</span><br><span class="line">&#125; <span class="comment">// a n d y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. charCodeAt(index)  </span></span><br><span class="line"><span class="comment">//返回相应索引号的字符ASCII值 目的： 判断用户按下了那个键 </span></span><br><span class="line"><span class="built_in">console</span>.log(str.charCodeAt(<span class="number">0</span>)); <span class="comment">// 97</span></span><br><span class="line"><span class="comment">// 3. str[index] H5 新增的</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">0</span>]); <span class="comment">// a</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数</p>
</li>
<li><ol>
<li>核心算法：利用 charAt() 遍历这个字符串</li>
<li>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</li>
<li>遍历对象，得到最大值和该字符 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象中，对应的属性值是该字符出现的次数</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcoefoxyozzopp&quot;</span>;</span><br><span class="line"><span class="comment">// 创建一个空对象来存储每一个字符(键)和对应的次数(值)</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;; <span class="comment">//创建了一个对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> chars = str.charAt(i); <span class="comment">// chars 是字符串的每一个字符</span></span><br><span class="line">    <span class="comment">//开始的时候是空对象,o[chars]这个属性值(字符次数为0) </span></span><br><span class="line">    <span class="comment">//o[chars]=1说明 这个字符之前已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (o[chars]) &#123; <span class="comment">//存在则计数加1次</span></span><br><span class="line">        o[chars]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行下边语句o[chars]=0 ,证明之前这个键在对像里没有,则新建储存一次</span></span><br><span class="line">    <span class="comment">//如o[a]=undefined，则新建并储存&#123;a:1&#125;</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//不存在则新建一次</span></span><br><span class="line">        o[chars] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="comment">// 2. 遍历对象</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> ch = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="comment">// k 得到是 属性名</span></span><br><span class="line">    <span class="comment">// o[k] 得到的是属性值</span></span><br><span class="line">    <span class="keyword">if</span> (o[k] &gt; max) &#123;</span><br><span class="line">        max = o[k];</span><br><span class="line">        ch = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;最多的字符是&quot;</span> + ch);</span><br></pre></td></tr></table></figure>

<p><strong>「字符串操作方法」</strong></p>
<ul>
<li>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>concat(str1,str2,str3…)</strong></td>
<td>concat() 方法用于连接两个或对各字符串。拼接字符串</td>
</tr>
<tr>
<td><strong>substr(start,length)</strong></td>
<td>从 start 位置开始(索引号), length 取的字符个数。</td>
</tr>
<tr>
<td>slice(start,end)</td>
<td>从 start 位置开始，截取到 end 位置 ，end 取不到 (两个都是索引号)</td>
</tr>
<tr>
<td>substring(start,end)</td>
<td>从 start 位置开始，截取到 end 位置 ，end 取不到 (基本和 slice 相同，但是不接受负)</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串操作方法</span></span><br><span class="line"><span class="comment">// 1. concat(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;....)</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;andy&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.concat(<span class="string">&#x27;red&#x27;</span>)); <span class="comment">// andyred</span></span><br><span class="line"><span class="comment">// 2. substr(&#x27;截取的起始位置&#x27;, &#x27;截取几个字符&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;改革春风吹满地&#x27;</span>;</span><br><span class="line"><span class="comment">// 第一个2 是索引号的2 从第几个开始  第二个2 是取几个字符</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.substr(<span class="number">2</span>, <span class="number">2</span>)); <span class="comment">// 春风</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>replace()方法</strong></p>
</li>
<li><ul>
<li>replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">字符串.replace(被替换的字符串，要替换为的字符串)；</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="string">&#x27;改革春风吹满地&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str1.replace(<span class="string">&#x27;春风&#x27;</span>, <span class="string">&#x27;号角&#x27;</span>));<span class="comment">//改革号角吹满地</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>split()方法</strong></p>
</li>
<li><ul>
<li>split()方法用于切分字符串，它可以将字符串切分为<strong>数组</strong>。在切分完毕之后，<strong>返回的是一个新数组。</strong></li>
<li>其使用格式如下：字符串.split(“分割字符”)将字符串按’分割字符’分割出来</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">字符串.split(<span class="string">&quot;分割字符&quot;</span>)</span><br><span class="line"><span class="comment">// 1. 替换字符 replace(&#x27;被替换的字符&#x27;, &#x27;替换为的字符&#x27;)  它只会替换第一个字符</span></span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">&quot;andyandy&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)); <span class="comment">// bndyandy</span></span><br><span class="line"><span class="comment">// 有一个字符串 &#x27;abcoefoxyozzopp&#x27;  要求把里面所有的 o 替换为 *</span></span><br><span class="line">    <span class="keyword">var</span> str1 = <span class="string">&quot;abcoefoxyozzopp&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (str1.indexOf(<span class="string">&quot;o&quot;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      str1 = str1.replace(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(str1); <span class="comment">// abc*ef*xy*zz*pp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 字符转换为数组 split(&#x27;分隔符&#x27;)    </span></span><br><span class="line"><span class="comment">// 前面我们学过 join 把数组转换为字符串</span></span><br><span class="line">    <span class="keyword">var</span> str2 = <span class="string">&quot;red, pink, blue&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str2.split(<span class="string">&quot;,&quot;</span>)); <span class="comment">//[red,pink,blue]</span></span><br><span class="line">    <span class="keyword">var</span> str3 = <span class="string">&quot;red&amp;pink&amp;blue&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str3.split(<span class="string">&quot;&amp;&quot;</span>)); <span class="comment">// [red,pink,blue]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>元素显示模式笔记（思维导图）</title>
    <url>/2021/09/22/%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h1><p><img src="http://blog.nekoame.club/usr/uploads/2021/09/1802855579.png"></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>元素显示模式</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/28/%E5%85%83%E7%B4%A0%E7%9A%84%E6%98%BE%E7%A4%BA%E4%B8%8E%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<h1 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" class="headerlink" title="元素的显示与隐藏"></a>元素的显示与隐藏</h1><h4 id="1-1-display-显示（重点）"><a href="#1-1-display-显示（重点）" class="headerlink" title="1.1 display 显示（重点）"></a>1.1 display 显示（重点）</h4><p>display设置或检索对象是否显示或如何显示。</p>
<ul>
<li><p>display: none 隐藏对象</p>
</li>
<li><ul>
<li>特点：隐藏之后，**<code>不再保留位置。</code>**</li>
</ul>
</li>
<li><p>display: block 除了转换为块级元素之外，同时还有显示元素的意思。</p>
</li>
</ul>
<p><code>实际开发场景</code>：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.mask</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line">当鼠标放到box上时候，则显示隐藏的<span class="attribute">mask</span>遮罩元素</span><br></pre></td></tr></table></figure>



<h4 id="1-2-visibility-可见性"><a href="#1-2-visibility-可见性" class="headerlink" title="1.2 visibility 可见性"></a>1.2 visibility 可见性</h4><p>设置或检索是否显示对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">visibility：visible ;  对象可视</span><br><span class="line"></span><br><span class="line">visibility：hidden;    对象隐藏</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：隐藏之后，<code>继续保留原有位置</code>。</li>
</ul>
<h4 id="1-3-overflow-溢出"><a href="#1-3-overflow-溢出" class="headerlink" title="1.3 overflow 溢出"></a>1.3 overflow 溢出</h4><p>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</p>
<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">visible</td>
<td align="left">不剪切内容也不添加滚动条</td>
</tr>
<tr>
<td align="left">hidden</td>
<td align="left">不显示超过对象尺寸的内容，超出的部分隐藏掉</td>
</tr>
<tr>
<td align="left">scroll</td>
<td align="left">不管超出内容否，总是显示滚动条</td>
</tr>
<tr>
<td align="left">auto</td>
<td align="left">超出自动显示滚动条，不超出不显示滚动条</td>
</tr>
</tbody></table>
<p><code>实际开发场景</code>：</p>
<ol>
<li>清除浮动</li>
<li>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</li>
</ol>
<h4 id="1-4-显示与隐藏总结"><a href="#1-4-显示与隐藏总结" class="headerlink" title="1.4 显示与隐藏总结"></a>1.4 显示与隐藏总结</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">区别</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">display</td>
<td align="left">隐藏对象，<strong>不保留位置</strong></td>
<td align="left">配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td>
</tr>
<tr>
<td align="left">visibility</td>
<td align="left">隐藏对象，<strong>保留位置</strong></td>
<td align="left">使用较少</td>
</tr>
<tr>
<td align="left">overflow</td>
<td align="left">只是隐藏超出大小的部分</td>
<td align="left">1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>复合选择器笔记（思维导图）</title>
    <url>/2021/09/22/%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><p><img src="http://blog.nekoame.club/usr/uploads/2021/09/3362048325.png"></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>思维导图</tag>
        <tag>复合选择器</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/28/%E5%9C%86%E8%A7%92%E8%BE%B9%E6%A1%86/</url>
    <content><![CDATA[<h2 id="圆角边框"><a href="#圆角边框" class="headerlink" title="圆角边框"></a><strong>圆角边框</strong></h2><p>border-radius: length;</p>
<p>border-top-left-radius  定义了左上角的弧度<br>border-top-right-radius  定义了右上角的弧度<br>border-bottom-right-radius  定义了右下角的弧度<br>border-bottom-left-radius  定义了左下角的弧度</p>
<p><strong>border-radius: 左上角 右上角 右下角 左下角;</strong></p>
<ol>
<li>四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。</li>
<li>三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角</li>
<li>两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角</li>
<li>一个值：四个圆角值相同</li>
</ol>
<p>其中每一个值可以为 数值或百分比的形式。</p>
<p>技巧：让一个正方形 变成圆圈，圆角矩形也同理。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>; <span class="comment">/*或者是正方形的边长一半*/</span></span><br></pre></td></tr></table></figure>

<h2 id="盒子阴影（box-shadow）"><a href="#盒子阴影（box-shadow）" class="headerlink" title="盒子阴影（box-shadow）"></a>盒子阴影（box-shadow）</h2><p><strong>阴影不占用空间，不影响其他盒子排列</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: offset-x offset-y [blur [spread]] [color] [inset]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">offset-x</td>
<td align="left">阴影的水平偏移量。正数向右偏移，负数向左偏移。</td>
</tr>
<tr>
<td align="left">offset-y</td>
<td align="left">阴影的垂直偏移量。正数向下偏移，负数向上偏移。</td>
</tr>
<tr>
<td align="left">blur</td>
<td align="left">可选。阴影模糊距离，越大越影子模糊，不能取负数。</td>
</tr>
<tr>
<td align="left">spread</td>
<td align="left">可选。阴影大小</td>
</tr>
<tr>
<td align="left">color</td>
<td align="left">可选。阴影的颜色</td>
</tr>
<tr>
<td align="left">inset</td>
<td align="left">可选。表示添加内阴影，默认为外阴影，（不可以写outset）</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */</span></span><br><span class="line">   <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">15px</span> <span class="number">30px</span>  <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">4</span>);   </span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/28/%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p><strong>「1. 定位详解」</strong></p>
<p>将盒子<strong>「定」</strong>在某一个<strong>「位」</strong>置  自由的漂浮在其他盒子(包括标准流和浮动)的上面。</p>
<p>所以，我们脑海应该有三种布局机制的上下顺序👇👇<br>标准流在最底层 (海底)  ——-   浮动 的盒子 在 中间层  (海面)  ——-  定位的盒子 在 最上层  （天空）</p>
<p><strong>定位</strong>是用来布局的，它有两部分组成：定位 = 定位模式 + 边偏移</p>
<p>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>「边偏移」</strong>：（方位名词）</p>
<table>
<thead>
<tr>
<th align="left">边偏移属性</th>
<th align="left">示例</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>top</code></td>
<td align="left"><code>top: 80px</code></td>
<td align="left"><strong>「顶端」</strong>偏移量，定义元素相对于其父元素<strong>「上边线的距离」</strong>。</td>
</tr>
<tr>
<td align="left"><code>bottom</code></td>
<td align="left"><code>bottom: 80px</code></td>
<td align="left"><strong>「底部」</strong>偏移量，定义元素相对于其父元素<strong>「下边线的距离」</strong>。</td>
</tr>
<tr>
<td align="left"><code>left</code></td>
<td align="left"><code>left: 80px</code></td>
<td align="left"><strong>「左侧」</strong>偏移量，定义元素相对于其父元素<strong>「左边线的距离」</strong>。</td>
</tr>
<tr>
<td align="left"><code>right</code></td>
<td align="left"><code>right: 80px</code></td>
<td align="left"><strong>「右侧」</strong>偏移量，定义元素相对于其父元素<strong>「右边线的距离」</strong></td>
</tr>
</tbody></table>
<p><strong>「2. 定位模式(position)」</strong>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>「定位模式」</strong>，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器 &#123; position: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">值</th>
<th align="center">语义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static</code></td>
<td align="center"><strong>「静态」</strong>定位</td>
</tr>
<tr>
<td align="left"><code>relative</code></td>
<td align="center"><strong>「相对」</strong>定位</td>
</tr>
<tr>
<td align="left"><code>absolute</code></td>
<td align="center"><strong>「绝对」</strong>定位</td>
</tr>
<tr>
<td align="left"><code>fixed</code></td>
<td align="center"><strong>「固定」</strong>定位</td>
</tr>
</tbody></table>
<p><strong>「3. 静态定位(static)」</strong></p>
<ul>
<li>静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。</li>
<li>静态定位 按照标准流特性摆放位置。它没有边偏移。</li>
<li>静态定位在布局时几乎不用</li>
</ul>
<p><strong>「4. 相对定位(relative)」</strong></p>
<ul>
<li>相对定位是元素相对于它原来在标准流中的位置来说的。</li>
<li>相对于自己原来在标准流中位置来移动的</li>
<li>原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。</li>
</ul>
<p><strong>「5. 绝对定位(absolute)」</strong></p>
<p>绝对定位是元素以带有定位的父级元素来移动位置</p>
<ul>
<li>完全脱标–完全<strong>不占位置</strong>；</li>
<li>如果父元素没有定位（position），则以浏览器为准定位(Document文档)。</li>
</ul>
<blockquote>
<p>绝对定位/固定定位的盒子不能通过设置margin: auto设置水平居中 在使用绝对定位时要向实现水平居中，可以按照下面的方法：</p>
</blockquote>
<ol>
<li>left : 50%:让盒子的左侧移动到父级元素的水平中心位置；</li>
<li>margin-left: -100px;让盒子向左移动自身宽度200px的一半。</li>
<li>同理垂直居中。</li>
</ol>
<h4 id="父元素有定位"><a href="#父元素有定位" class="headerlink" title="父元素有定位"></a>父元素有定位</h4><h5 id="定位口诀–子绝父相"><a href="#定位口诀–子绝父相" class="headerlink" title="定位口诀–子绝父相"></a>定位口诀–子绝父相</h5><p>​            例如图片的左右滑动切换按钮和小点，则是采用了子绝父相。</p>
<p><strong>「6. 固定定位(fixed)」</strong></p>
<p>固定定位是绝对定位的一种特殊形式;</p>
<ul>
<li><p>完全脱标–完全不占位置；</p>
</li>
<li><p>只认<strong>浏览器的可视窗口</strong>–浏览器可视窗口+边偏移属性来设置元素的位置</p>
<p>​    跟父元素没有任何关系；单独使用</p>
<p>​    不随滚动条滚动</p>
</li>
</ul>
<p><strong>固定小技巧，固定在版心右侧：</strong></p>
<p>​        1、先让固定盒子left：50%，走到浏览器可视区域中心的右侧。</p>
<p>​        2、让固定册子的margin-left：版心宽度的一半距离。则可以让盒子贴着版心右侧对齐。</p>
<p><strong>「7. 粘性定位(sticky)」</strong></p>
<p>​    特点：相对定位和固定定位的混合，拉到顶住则变为固定定位，兼容性差，ie不支持。</p>
<ol>
<li>以浏览器的可视窗口作为参照点移动元素（固定定位特点）</li>
<li>粘性定位<strong>占有原先的位置</strong>（相对定位特点）</li>
<li>必须添加top、left、right、bottom其中一个才有效</li>
</ol>
<h4 id="定位小结"><a href="#定位小结" class="headerlink" title="定位小结"></a>定位小结</h4><table>
<thead>
<tr>
<th align="left">定位模式</th>
<th align="left">是否脱标占有位置</th>
<th align="left">移动位置基准</th>
<th align="left">模式转换（行内块）</th>
<th align="left">使用情况</th>
</tr>
</thead>
<tbody><tr>
<td align="left">静态static</td>
<td align="left">不脱标，正常模式</td>
<td align="left">正常模式</td>
<td align="left">不能</td>
<td align="left">几乎不用</td>
</tr>
<tr>
<td align="left"><strong>相对定位relative</strong></td>
<td align="left"><strong>不脱标，占有位置</strong></td>
<td align="left"><strong>相对自身位置移动</strong></td>
<td align="left"><strong>不能</strong></td>
<td align="left"><strong>基本单独使用</strong></td>
</tr>
<tr>
<td align="left"><strong>绝对定位absolute</strong></td>
<td align="left"><strong>完全脱标，不占有位置</strong></td>
<td align="left"><strong>相对于定位父级移动位置</strong></td>
<td align="left"><strong>能</strong></td>
<td align="left"><strong>要和定位父级元素搭配使用</strong></td>
</tr>
<tr>
<td align="left"><strong>固定定位fixed</strong></td>
<td align="left"><strong>完全脱标，不占有位置</strong></td>
<td align="left"><strong>相对于浏览器可视区域移动位置</strong></td>
<td align="left"><strong>能</strong></td>
<td align="left"><strong>单独使用，不需要父级</strong></td>
</tr>
<tr>
<td align="left">sticky粘性定位</td>
<td align="left">否（占有位置）</td>
<td align="left">浏览器可视区</td>
<td align="left"></td>
<td align="left">当前阶段少</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<ol>
<li><code>边偏移</code> 需要和 <code>定位模式</code> 联合使用，<code>单独使用无效</code>；</li>
<li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li>
<li><code>left</code> 和 <code>right</code> 不要同时使用。</li>
</ol>
<h4 id="堆叠顺序（z-index）"><a href="#堆叠顺序（z-index）" class="headerlink" title="堆叠顺序（z-index）"></a>堆叠顺序（z-index）</h4><p>在使用<strong>「定位」</strong>布局时，可能会<strong>「出现盒子重叠的情况」</strong>。</p>
<p>加了定位的盒子，默认<strong>「后来者居上」</strong>， 后面的盒子会压住前面的盒子。</p>
<p>应用 <code>z-index</code> 层叠等级属性可以<strong>「调整盒子的堆叠顺序」</strong>。如下图所示：</p>
<p>z-index的特性如下:</p>
<ol>
<li><strong>属性值</strong>：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上；</li>
<li>如果属性值相同，则按照书写顺序，后来居上；</li>
<li>数字后面不能加单位</li>
<li>z-index只能用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/28/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>清除浮动的方法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">clear</span>: 属性值; &#125;   <span class="attribute">clear</span> 清除  </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">left</td>
<td align="left">不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td align="left">both</td>
<td align="left">同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<p>实际工作中,几乎只用clear: both</p>
<p><strong>1).额外标签法(隔墙法，W3C推荐的做法)</strong></p>
<p>​    通过在浮动元素末尾添加一个空的标签，阻挡后面的浮动标签，例如 <div style="clear:both"></div>，或则其他标签br等亦可。</p>
<p>​    <strong>墙必须是块级元素，不能是行内元素。</strong></p>
<p>​    阻挡后父盒子有高度，孩子有多高则高度为多少。</p>
<ul>
<li>优点：通俗易懂，书写方便</li>
<li>缺点：添加许多无意义的标签，结构化较差。</li>
</ul>
<p><strong>2).父级添加overflow属性方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。</span><br></pre></td></tr></table></figure>

<ul>
<li>优点： 代码简洁</li>
<li>缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</li>
</ul>
<p><strong>3).使用after伪元素清除浮动</strong>:after 方式为空元素额外标签法的升级版，<strong>给父标签添加</strong>，好处是不用单独加标签了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">写法复制 <span class="selector-class">.clearfix</span>:after &#123;	在父元素内部后面添加了个盒子，</span><br><span class="line">        content: <span class="string">&quot;&quot;</span>;		不需要在子盒子一起单独多加标签了</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">clear</span>: both;</span><br><span class="line">        <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* IE6、7 专有 */</span></span><br><span class="line">    <span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">        *zoom: <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<ul>
<li>优点：符合闭合浮动思想  结构语义化正确</li>
<li>缺点：由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</li>
</ul>
<p><strong>4).使用双伪元素清除浮动</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:before,</span><br><span class="line">.clearfix:after &#123;</span><br><span class="line">    content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span>:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">   *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>优点： 代码更简洁，代表网站：小米，腾讯</li>
<li>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</li>
</ul>
<h4 id="清除浮动总结"><a href="#清除浮动总结" class="headerlink" title="清除浮动总结"></a>清除浮动总结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么时候用清除浮动呢？</span><br></pre></td></tr></table></figure>

<ol>
<li>父级没高度</li>
<li>子盒子浮动了</li>
<li>影响下面布局了，我们就应该清除浮动了。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">清除浮动的方式</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">额外标签法（隔墙法）</td>
<td align="left">通俗易懂，书写方便</td>
<td align="left">添加许多无意义的标签，结构化较差。</td>
</tr>
<tr>
<td align="left">父级overflow:hidden;</td>
<td align="left">书写简单</td>
<td align="left">溢出隐藏</td>
</tr>
<tr>
<td align="left">父级after伪元素</td>
<td align="left">结构语义化正确</td>
<td align="left">由于IE6-7不支持:after，兼容性问题</td>
</tr>
<tr>
<td align="left">父级双伪元素</td>
<td align="left">结构语义化正确</td>
<td align="left">由于IE6-7不支持:after，兼容性问题</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/28/%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<p>CSS 提供了3种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中：</p>
<p><strong>A. 普通流（标准流）</strong></p>
<ul>
<li><p>块级元素会独占一行，从上向下顺序排列；</p>
</li>
<li><ul>
<li>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li>
</ul>
</li>
<li><p>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行；</p>
</li>
<li><ul>
<li>常用元素：span、a、i、em等</li>
</ul>
</li>
</ul>
<p><strong>B. 浮动</strong></p>
<ul>
<li>让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示，<strong>而且不会有空白缝隙</strong>，分别靠左靠右对齐。</li>
<li>可以改变标签的默认排列方式</li>
<li><strong>最初是为了使文字环绕图片的效果，所以和浮动图片和文字在一起时，不会压住文字内容，而会使文字环绕图片。</strong></li>
</ul>
<p><strong>C. 定位</strong></p>
<ul>
<li>将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123; <span class="attribute">float</span>: 属性值; &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">none</td>
<td align="left">元素不浮动（默认值）</td>
</tr>
<tr>
<td align="left">left</td>
<td align="left">元素向左浮动</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">元素向右浮动</td>
</tr>
</tbody></table>
<p>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流，因为前面的标准流自己占一个位置。<br>**建议:**如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</p>
<p><strong>特性：</strong>元素的浮动是指设置了浮动属性的元素会</p>
<ul>
<li>脱离标准普通流的控制,不占位置，脱标</li>
<li>移动到指定位置。</li>
</ul>
<p><strong>浮动(float)小结</strong></p>
<table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">浮</td>
<td align="left">加了浮动的盒子<strong>「是浮起来」</strong>的，漂浮在其他标准流盒子的上面。</td>
</tr>
<tr>
<td align="left">漏</td>
<td align="left">加了浮动的盒子<strong>「是不占位置的」</strong>，它原来的位置<strong>「漏给了标准流的盒子」</strong>。</td>
</tr>
<tr>
<td align="left">特</td>
<td align="left"><strong>「特别注意」</strong>：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙</td>
</tr>
</tbody></table>
<p><strong>约束浮动元素位置，通常采用的策略：</strong></p>
<p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，使浮动控制在标准流中</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a><strong>清除浮动</strong></h2><p>不是所有父盒子都有高度，因为每个内容长度数量都不一样，应当让子浮动盒子自动撑开父盒子</p>
<p><strong>总结：</strong></p>
<ul>
<li>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响</li>
<li>准确地说，并不是清除浮动，而是清除浮动后造成的影响</li>
</ul>
<p><strong>清除浮动本质</strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</p>
<h4 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选择器 &#123; clear: 属性值; &#125;   clear 清除  </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">left</td>
<td align="left">不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td align="left">right</td>
<td align="left">不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td align="left">both</td>
<td align="left">同时清除左右两侧浮动的影响</td>
</tr>
</tbody></table>
<p>实际工作中,几乎只用clear: both</p>
]]></content>
  </entry>
  <entry>
    <title>清除元素的默认内外边距</title>
    <url>/2021/11/28/%E7%9B%B8%E9%82%BB%E5%9D%97%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%A4%96%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<p><strong>清除元素的默认内外边距👇👇</strong></p>
<ul>
<li>行内元素为了照顾兼容性,尽量只设置左右内外边距，不要设置上下内外边距。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;         <span class="comment">/* 清除内边距 */</span></span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;          <span class="comment">/* 清除外边距 */</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>使用margin定义块元素的<strong>「垂直外边距」</strong>时，可能会出现外边距的合并。</p>
<h6 id="1-相邻块元素垂直外边距的合并"><a href="#1-相邻块元素垂直外边距的合并" class="headerlink" title="(1). 相邻块元素垂直外边距的合并"></a>(1). 相邻块元素垂直外边距的合并</h6><ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</li>
<li>下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和</li>
<li><strong>「取两个值中的较大者」</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/y7EkeCWAzmqtcdL7HZYccBic0jicaWzR8b15wO9U7G1QHGZRB5OIsdJaCdPeg7MzVYtTsbhfGPusK7OCOwWtvs4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>「解决方案：尽量给只给一个盒子添加margin值」</strong>。</p>
<h4 id="2-嵌套块元素垂直外边距的合并（塌陷）"><a href="#2-嵌套块元素垂直外边距的合并（塌陷）" class="headerlink" title="(2). 嵌套块元素垂直外边距的合并（塌陷）"></a>(2). 嵌套块元素垂直外边距的合并（塌陷）</h4><ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/y7EkeCWAzmqtcdL7HZYccBic0jicaWzR8by8DvQuDYlXKtzlIWtltPGPW0HtWAqoaWKr6cy6jYzc4hrVmR6CFlDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>「解决方案：」</strong></p>
<ol>
<li>可以为父元素定义上边框。</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加overflow: hidden。</li>
</ol>
<p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p>
<h4 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h4><p>优先使用  宽度 （width）  其次 使用内边距（padding）   再次  外边距（margin）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">width &gt;  padding  &gt;   margin   </span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<ul>
<li>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</li>
<li>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li>
<li>width  没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</li>
</ul>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
